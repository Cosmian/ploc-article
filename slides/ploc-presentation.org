#+title: All paths lead to the root
#+options: author:nil
#+latex_header: \usepackage{tikz}
#+bibliography: ../ploc-article.bib
#+latex_header: \renewcommand{\sec}{\textrm{sec}}
#+latex_header: \newcommand{\msec}{\textrm{msec}}

** We are on [[https://eprint.iacr.org/2025/1672][e-print]]!

[[file:img/e-print.png]]

* Searchable Symmetric Encryption (SSE)
** Retrieving data from a server?

#+begin_src dot  :exports results :file img/db0.svg :results replace
  graph DB_flow {
          compound=true;
          rankdir = LR;
          client[shape="rectangle"]
          subgraph cluster_server {
                  label="Server"
                  database[shape="cylinder"]
          }
          rank="same"
          client--database[label="get(label) -> data", minlen=4, lhead="cluster_server"]
  }
#+end_src

For example: label = "name=DUPONT".

| name   | surname | birth date | disease  |
|--------+---------+------------+----------|
| DUPONT | Charles |       1971 | diabetes |
| DUPONT | Marie   |       1988 | cancer   |
| ...    | ...     |        ... | ...      |

** Retrieving data from a server?

#+begin_quote
The server knows everything.
#+end_quote

** Controlling the leakage

#+begin_src dot  :exports results :file img/db-secure-search-0.svg :results replace
  graph DB_flow {
          compound=true;
          rankdir = LR;
          client[shape="rectangle"]
          subgraph cluster_server {
                  label="Adversary Server\n\n??\n"
                  database[shape="cylinder", label="Encrypted Database"]
          }
          rank="same"
          client--database[label="get(label) -> encrypted data", minlen=4, lhead="cluster_server"]
  }
#+end_src

\vfill

#+begin_quote
Encrypting the whole database breaks keyword search.
#+end_quote

\vfill

** Controlling the leakage

#+begin_src dot  :exports results :file img/db1.svg :results replace
  graph DB_flow {
          compound=true;
          rankdir = LR;
          client[shape="rectangle"]
          subgraph cluster_server {
                  label="Server"
                  subgraph cluster_DB {
                          label="Database"
                          node[shape="cylinder"]
                          indexes[label="\nindexes\n\nget(label)->location"];
                          storage[label="\nstorage\n\nget(location)->data"];
                  }
          }
          rank="same"
          client--indexes[label="get(label) -> data", minlen=4, lhead="cluster_server"]
  }
#+end_src

** Controlling the leakage

#+begin_src dot  :exports results :file img/db-secure-search.svg :results replace
  graph DB_flow {
          rankdir = LR;
          client[shape="rectangle"]
          subgraph cluster_server {
                  label="Adversary Server"
                  subgraph cluster_DB {
                          label="Database"
                          node[shape="cylinder"]
                          indexes[label="SSE (indexes)"];
                          storage[label="SE  (storage)"];
                  }
          }
          rank="same"
          client--indexes[label="1. secure-search(label)"     minlen=4]
          client--storage[label="2. secure-search(location)"  minlen=4]
  }
#+end_src

Leaks:
1. $\mathcal L_{SSE}(Search, label)$;
2. $\mathcal L_{SE}(Search, location)$.

** Supporting dynamic states

#+begin_src dot  :exports results :file img/db-secure-insert.svg :results replace
  graph DB_flow {
          rankdir = LR;
          client[shape="rectangle"]
          subgraph cluster_server {
                  label="Adversary Server"
                  subgraph cluster_DB {
                          label="Database"
                          node[shape="cylinder"]
                          indexes[label="SSE (indexes)"];
                          storage[label="SE  (storage)"];
                  }
          }
          rank="same"
          client--storage[label="1. secure-insert(data)"            minlen=4]
          client--indexes[label="2. secure-insert(label, location)" minlen=4]
  }
#+end_src

Leaks:
1. $\mathcal L_{SE}(Insert, data)$.
2. $\mathcal L_{SSE}(Insert, label, location)$;

** Supporting concurrent queries

#+begin_src dot  :exports results :file img/db-secure-concurrent.svg :results replace
  graph DB_flow {
          rankdir = LR;
          client1[label="client 1" shape="rectangle"]
          client2[label="client 2" shape="rectangle"]
          client3[label="client 3" shape="rectangle"]
          subgraph cluster_server {
                  label="Adversary Server"
                  subgraph cluster_DB {
                          label="Database"
                          node[shape="cylinder"]
                          indexes[label="SSE (indexes)"];
                          storage[label="SE  (storage)"];
                  }
          }
          rank="same"
          client1--indexes[label="1. secure-search(label)"    minlen=4]
          client1--storage[label="2. secure-search(location)" minlen=4]
          client2--storage[label="1. secure-insert(data)"     minlen=4]
          client2--indexes[label="2. secure-insert(location)" minlen=4]
          client3--indexes[label="1. secure-search(label)"    minlen=4]
          client3--storage[label="2. secure-search(location)" minlen=4]
  }
#+end_src

* Structured Encryption
** Index

*Index ADT*:
- /States/: $\mathbb{L}^{ \mathbb{V}^*}$
- /Operations/:
  - Search :: ~:: state -> label -> Set value~
  - Insert :: ~:: state -> label -> value -> ()~

*Index STE*:
- /States/: $\mathbb{K}^{\mathbb{L}^{\mathbb{V}^*}}$
- /Operations/:
  - Setup  :: ~:: () -> IO key~
  - Search :: ~:: key -> label -> IO (Set value)~
  - Insert :: ~:: key -> label -> value -> IO ()~

** Multi-Map (MM)

*MM ADT*:
- /States/: $\mathbb{L}^{ \mathbb{V}^*}$
- /Operations/:
  - Search :: ~:: state -> label -> List value~
  - Insert :: ~:: state -> label -> value -> ()~

*MM STE*:
- /States/: $\mathbb{K}^{\mathbb{L}^{\mathbb{V}^*}}$
- /Operations/:
  - Setup  :: ~:: () -> IO key~
  - Search :: ~:: key -> label -> IO (List value)~
  - Insert :: ~:: key -> label -> value -> IO ()~

** Multi-Map STE to Index STE transformation

  #+begin_example
    Index::setup  = MM::setup
    Index::insert = MM::insert
    Index::search = unique . MM::search
                    where
                      unique = fold Set::insert EmptySet
  #+end_example

* Why bother implementing a more constrained ADT?
** Semi-dynamic MM to fully-dynamic MM transformation

*Associative ADT*:
- /States/: $\mathbb{L}^{ \mathbb{T}(\mathbb{V})}$
- /Operations/:
  - Search :: ~:: s -> l -> T v~
  - Mutate :: ~:: s -> l -> (T v -> T v) -> ()~

** Semi-dynamic MM to fully-dynamic MM transformation

The fully-dynamic Multi-Map is an associative ADT:
#+begin_example
  MM::Search s l v ~ Search s l v
  MM::Insert s l v ~ Mutate s l (Cons v)
  MM::Delete s l v ~ Mutate s l (remove v)
                     where
                       remove v []    = []
                       remove v [v l] = remove v l
                       remove v [w l] = Cons w (remove v l)
#+end_example

** Semi-dynamic MM to fully-dynamic MM transformation

#+begin_quote
Mutations  are  composable[fn::More  precisely,  they  form  a  monoid  and  can
therefore be reduced.]: all we need is to log them!
#+end_quote
\vspace{1em}

*Journaling Multi-Map ADT*:
- /States/: $\mathbb L^{(\mathbb T(\mathbb V)^{\mathbb{T}(\mathbb{V})})^*}$
- /Operations/:
  + Search :: ~state -> l -> List (T v -> T v)~
  + Insert :: ~state -> l -> (T v -> T v) -> ()~

** Semi-dynamic MM to fully-dynamic MM transformation

\vfill

#+begin_quote
Implementing any (fully-dynamic) associative ADT on top of a (semi-dynamic)
multi-map is therefore simple!
#+end_quote

\vfill

#+begin_example
search s l     = let transformations = MM::search s l
                 in (reduce transformations) T::empty

mutate s l m v = MM::insert s l (m v)
#+end_example

\vfill

* \textsc{PLOC} is actually /simple/!
** Challenge

*MM STE*:
- /States/: $\mathbb{K}^{\mathbb{L}^{\mathbb{V}^*}}$
- /Operations/:
  - Setup  :: ~:: () -> IO key~
  - Search :: ~:: key -> label -> IO (List value)~
  - Insert :: ~:: key -> label -> value -> IO ()~
  \vspace{1em}

*Objectives*:
1. Do not to leak anything during insertion: $\mathcal L(Insert, label, value) =
   \bot$
2. Only leak a (meaningless) UID of the label: $\mathcal L(Search, label) =
   \mathrm{sp}$

** Search

Simply derive the set of target branches:
- $\mathrm{PRF}(key, cat, 0) = 3 \mod 8 = \mathtt{b...011}$
- $\mathrm{PRF}(key, cat, 1) = 2 \mod 8 = \mathtt{b...010}$
- $\mathrm{PRF}(key, cat, 2) = 6 \mod 8 = \mathtt{b...110}$

Mind the endianness!

#+begin_export latex
\begin{figure}[h]
\center
\begin{tikzpicture}[thick,
  level 1/.style={sibling distance=3cm},
  level 2/.style={sibling distance=1.5cm},
  level 3/.style={sibling distance=.75cm}]
  \node [draw, circle] {} [red]
  child { node [draw, circle] {}
    child [black] { node [draw, circle] {}
      child { node [draw, circle] { 0 } edge from parent node[left]  {0}}
      child { node [draw, circle] { 4 } edge from parent node[right] {1}}
      edge from parent node[left] {0}
    }
    child { node [draw, circle] {}
      child { node [draw, circle] { 2 } edge from parent node[left]  {0} }
      child { node [draw, circle] { 6 } edge from parent node[right] {1} }
      edge from parent node[right] {1}
    }
    edge from parent node[left] {0}
  }
  child { node [draw, circle] {}
    child [black] { node [draw, circle] {}
      child { node [draw, circle] { 1 } edge from parent node[left]  {0} }
      child { node [draw, circle] { 5 } edge from parent node[right] {1} }
      edge from parent node[left] {0}
    }
    child { node [draw, circle] {}
      child { node [draw, circle] { 3 }          edge from parent node[left]  {0}}
      child [black] { node [draw, circle] { 7 }  edge from parent node[right] {1}}
      edge from parent node[right] {1}
   }
   edge from parent node[right] {1}
  }
  ;
\end{tikzpicture}
\end{figure}
#+end_export

** Insert -- Datum

~type Datum = target * value~ \newline

#+begin_quote
A datum must always be stored on its target branch.
#+end_quote

For example with ~(6 food)~:

#+begin_export latex
\begin{figure}[h]
\center
\begin{tikzpicture}[thick,
  level 1/.style={sibling distance=3cm},
  level 2/.style={sibling distance=1.5cm},
  level 3/.style={sibling distance=.75cm}]
  \node [draw, circle] {} [red]
  child { node [draw, circle] {}
    child [black] { node [draw, circle] {}
      child { node [draw, circle] { }}
      child { node [draw, circle] { }}
    }
    child { node [draw, circle] {}
      child [black] { node [draw, circle] { 2 }}
      child { node [draw, circle] { 6 }}
    }
  }
  child [black] { node [draw, circle] {}
    child { node [draw, circle] {}
      child { node [draw, circle] { }}
      child { node [draw, circle] { }}
    }
    child { node [draw, circle] {}
      child { node [draw, circle] { 3 }}
      child { node [draw, circle] { }}
   }
  }
  ;
\end{tikzpicture}
\end{figure}
#+end_export

** Insertion -- Uniform Scheduling

#+begin_export latex
\begin{figure}[h]
\begin{tabular}{cc}
\includegraphics[height=.25\textheight]{../img/tree-1.pdf}
&
\includegraphics[height=.25\textheight]{../img/tree-2.pdf}
\\
$t=0$ & $t=1$
\\
&
\\
\includegraphics[height=.25\textheight]{../img/tree-3.pdf}
&
\includegraphics[height=.25\textheight]{../img/tree-4.pdf}
\\
$t=2$ & $t=3$
\\
\end{tabular}
\caption{Scheduled subtrees for $N=8$ and $n=2$.\label{fig:scheduling}}
\end{figure}
#+end_export

** Insert -- Compaction 1

#+begin_export latex
\begin{figure}
\center
\begin{tikzpicture}[thick,
  level 1/.style={sibling distance=6cm},
  level 2/.style={sibling distance=3cm},
  level 3/.style={sibling distance=1.5cm}]
  \node [draw, circle] {} [red]
  child { node [draw, circle] {(6 food)}
    child [black] { node [draw, circle] {}
      child { node [draw, circle] {} }
      child [dotted] { node [draw, circle] {} }
    }
    child [dotted] { node [draw, circle] {}
      child [black] { node [draw, circle] {} }
      child { node [draw, circle] { 6 } }
    }
  }
  child [black] { node [draw, circle] {}
    child { node [draw, circle] {}
      child { node [draw, circle] {} }
      child [dotted] { node [draw, circle] {} }
    }
    child [dotted] { node [draw, circle] {}
      child { node [draw, circle] {} }
      child { node [draw, circle] {} }
    }
  }
  ;
\end{tikzpicture}
\end{figure}
#+end_export

** Insert -- Compaction 2

#+begin_export latex
\begin{figure}
\center
\begin{tikzpicture}[thick,
  level 1/.style={sibling distance=6cm},
  level 2/.style={sibling distance=3cm},
  level 3/.style={sibling distance=1.5cm}]
  \node [draw, circle] {} [red]
  child { node [draw, circle] {}
    child [dotted, black] { node [draw, circle] {}
      child { node [draw, circle] {} }
      child { node [draw, circle] {} }
    }
    child { node [draw, circle] {(6 food)}
      child [black] { node [draw, circle] {} }
      child [dotted] { node [draw, circle] { 6 } }
    }
  }
  child [black] { node [draw, circle] {}
    child [dotted] { node [draw, circle] {}
      child { node [draw, circle] {} }
      child { node [draw, circle] {} }
    }
    child { node [draw, circle] {}
      child { node [draw, circle] {} }
      child [dotted] { node [draw, circle] {} }
    }
  }
  ;
\end{tikzpicture}
\end{figure}
#+end_export

** Insert -- Compaction 3

#+begin_export latex
\begin{figure}
\center
\begin{tikzpicture}[thick,
  level 1/.style={sibling distance=6cm},
  level 2/.style={sibling distance=3cm},
  level 3/.style={sibling distance=1.5cm}]
  \node [draw, circle] {} [red]
  child { node [draw, circle] {}
    child [black] { node [draw, circle] {}
      child [dotted] { node [draw, circle] {} }
      child { node [draw, circle] {} }
    }
    child [dotted] { node [draw, circle] {(6 food)}
      child [black] { node [draw, circle] {} }
      child { node [draw, circle] { 6 } }
    }
  }
  child [black] { node [draw, circle] {}
    child { node [draw, circle] {}
      child [dotted] { node [draw, circle] {} }
      child { node [draw, circle] {} }
    }
    child [dotted] { node [draw, circle] {}
      child { node [draw, circle] {} }
      child { node [draw, circle] {} }
    }
  }
  ;
\end{tikzpicture}
\end{figure}
#+end_export

** Insert -- Compaction 4

#+begin_export latex
\begin{figure}
\center
\begin{tikzpicture}[thick,
  level 1/.style={sibling distance=6cm},
  level 2/.style={sibling distance=3cm},
  level 3/.style={sibling distance=1.5cm}]
  \node [draw, circle] {} [red]
  child { node [draw, circle] {}
    child [dotted, black] { node [draw, circle] {}
      child { node [draw, circle] {} }
      child { node [draw, circle] {} }
    }
    child { node [draw, circle] {}
      child [dotted, black] { node [draw, circle] {} }
      child { node [draw, circle] { (6 food) } }
    }
  }
  child [black] { node [draw, circle] {}
    child [dotted] { node [draw, circle] {}
      child [dotted] { node [draw, circle] {} }
      child { node [draw, circle] {} }
    }
    child { node [draw, circle] {}
      child [dotted] { node [draw, circle] {} }
      child { node [draw, circle] {} }
    }
  }
  ;
\end{tikzpicture}
\end{figure}
#+end_export

** Insert -- Compaction

#+begin_quote
Can the compaction prevent tree overflow? \newline
#+end_quote

** Insert -- Compaction

#+begin_quote
Can the compaction prevent tree overflow? \newline
*yes* (but hard to prove)
#+end_quote

** Conclusion -- \textsc{ploc} is /injection-secure/

\vfill

- $\mathcal{L}(Search, label) = \{target\text{-}branch\}$

- $\mathcal{L}(Insert, label, value) = \bot$

\vfill

#+begin_quote
Complete decorrelation of mutations and their effects!
#+end_quote

\vfill

** Conclusion -- \textsc{ploc} is /efficient/

\vfill

With a /simple/ implementation[fn::Less than 400LoC!]:

\vfill

#+begin_export latex
\begin{table}
  \centering
  \begin{tabular}{l|lll}
    \(n\) $\backslash$\ \(B\) & \(2^{10}\) & \(2^{16}\) & \(2^{20}\)\\
    \hline
    \(16\) & \(2.1\msec \quad 1.8\msec\) & \(26\msec \quad 3.1\msec\) & \(0.17\sec \quad 3.8\msec\)\\
    \(64\) & \(2.1\msec \quad 5.4\msec\) & \(25\msec \quad 11\msec\) & \(0.12\sec \quad 13\msec\)\\
    \(256\) & \(2.0\msec \quad 18\msec\) & \(25\msec \quad 34\msec\) & \(0.12\sec \quad 45\msec\)\\
  \end{tabular}
  \caption{(\(Search \quad Insert\)) performances in function of \(n\) and \(B\) for \(V = \sqrt{B}\).}
\end{table}
#+end_export

\vfill

\vfill

** Conclusion -- \textsc{ploc} is /state-of-the-art/

#+begin_quote
Only FIX[fn::AC:AmjKamMoa23] achieves the same security properties... but not
the same efficiency!
#+end_quote

* Future works
** Can we improve the performance?

- Search performance is in $O(V)$:
  - can we store more than one datum per target branch? $\Rightarrow
    O(\frac{V}{m})$
    \vspace{2em}

- Search bandwidth is in $O(c \lg B)$:
  - can we reduce the depth by $\lg c$? $\Rightarrow O(\lg B)$

** What about concurrency?

Reliance on an synchronized mutable state due to:

- MM semantics (order)
    + implement the index directly?
    + relax progress property? \vspace{1em}

- Uniform scheduling (next scheduled branches)
    + can compaction work with a random scheduling?
    + relax progress property?

** What about concurrency?

Reliance on an synchronized mutable state due to:

- MM semantics (order) $O(L) \Rightarrow$ bad
    + +implement the index directly?+
    + relax progress property + relax target selection \vspace{1em}

- Uniform scheduling (next scheduled branches) $O(1)$
    + +can compaction work with a random scheduling?+
    + relax progress property?

** What about the data-related leakage?

- Store data directly inside the SSE?
  + what is the impact on performance?
    \newline
    \vspace{1em}
- Use an independent scheme with no leakage (ORAM)?
  + with what performances?
    \newline
  + can it be compatible with concurrent queries?
    \newline

** What about the data-related leakage?

- Store data directly inside the SSE?
  + what is the impact on performance?

    *Big* due to volume-hiding
    \vspace{1em}
- Use an independent scheme with no leakage (ORAM)?
  + with what performances?
    \newline
  + can it be compatible with concurrent queries?
    \newline

** What about the data-related leakage?

- Store data directly inside the SSE?
  + what is the impact on performance?

    *Big* due to volume-hiding
    \vspace{1em}
- Use an independent scheme with no leakage (ORAM)?
  + with what performances?

    *OK* $O(\log N)$
  + can it be compatible with concurrent queries?
    \newline

** What about the data-related leakage?

- Store data directly inside the SSE?
  + what is the impact on performance?

    *Big* due to volume-hiding
    \vspace{1em}
- Use an independent scheme with no leakage (ORAM)?
  + with what performances?

    *OK* $O(\log N)$
  + can it be compatible with concurrent queries?

    *NO* requires a lock

* Thanks!
